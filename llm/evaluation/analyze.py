import os
import sys
import shutil
import subprocess
import docker
import uuid
from pathlib import Path
import yaml
import time
from typing import List

EVAL_DIR = os.path.dirname(os.path.abspath(__file__))
LLM_DIR = os.path.dirname(EVAL_DIR)

# creates a build folder within current directory
os.makedirs("build", exist_ok = True)

output_dir = os.path.join(LLM_DIR, "build")
exp_dir = os.path.join(EVAL_DIR, "build")

if os.path.exists(exp_dir):
    shutil.rmtree(exp_dir)
os.makedirs(exp_dir, exist_ok=True)

# -----------------------------------------------------------------
# Generate once
# -----------------------------------------------------------------

def run_one(input_file, output_file):
    """
    Runs the agent on with the input xls file. Writes the log to output file
    
    :param input_file: the input xls source file
    :param output_file: the pull path to output log 
    """
    command = ["python3", "main.py", "--input_file", input_file]
    try:
        result = subprocess.run(
            command,
            cwd=LLM_DIR,
            capture_output=True,
            text=True,
            check=True,
        )
    except subprocess.CalledProcessError as e:
        print("Return code:", e.returncode)
        print("STDOUT:\n", e.stdout)
        print("STDERR:\n", e.stderr)
        raise  # or handle it however you want

    with open(output_file, "a") as f:
        f.write(result.stdout)
        f.write(result.stderr)

    time.sleep(1)

# -----------------------------------------------------------------
# Grab result for one generation
# -----------------------------------------------------------------

# Fields we care about (as they appear after "INFO - ")
TARGET_FIELDS = {
    "status",
    "input source",
    "final output file path",
    "prompt tokens",
    "completion tokens",
    "number of generations",
}

def parse_done_section(lines):
    """
    Given an iterable of log lines, extract the INFO - ... fields from
    the workflows.steps.done section and return them as a dict.
    """
    result = {}

    for line in lines:
        # Only look at lines from workflows.steps.done with INFO
        if "workflows.steps.done - INFO - " not in line:
            continue

        # Get the part after "INFO -"
        try:
            msg = line.split("INFO -", 1)[1].strip()
        except IndexError:
            continue

        # Expect "label: value"
        if ":" not in msg:
            continue

        label, value = [part.strip() for part in msg.split(":", 1)]

        if label in TARGET_FIELDS:
            # Convert numeric fields to int where appropriate
            if label in {"prompt tokens", "completion tokens", "number of generations"}:
                try:
                    result[label] = int(value)
                except ValueError:
                    # If conversion fails, just keep it as a string
                    result[label] = value
            else:
                result[label] = value

    return result

def analyze_once(output_file):
    """
    Analyze one output log
    
    :param output_file: Description
    """
    with open(output_file, "r") as f:
        content = f.readlines()
        print(f"{output_file}: {content[10]}")

        result = parse_done_section(content)
    
    return result

# -----------------------------------------------------------------
# Run interpreter
# -----------------------------------------------------------------

def verify_once(test_file, output_file, test_output_file):
    """
    Returns true if success, false if not
    Writes output to test_output_file
    
    :param test_file: the file that contains the test to dslx
    :param output_file: the final version of the dslx generated by the agent
    :param test_output_file: the result of running test on the dslx file
    """

    with open(output_file, "r") as f:
        content = f.read()

    with open(test_file, "r") as f:
        test = f.read()

    # append tests
    content += "\n" + test

    # docker
    container_name = "xls-ece6775-fa25"
    client = docker.from_env()
    container = client.containers.get(container_name)

    # copy file + test to docker image
    p = Path(output_file)
    output_path = f"/tmp/{p.stem}_{uuid.uuid4()}.txt"

    cmd = f'printf "%s" "$CONTENT" > {output_path}'
    exit_code, output = container.exec_run(
        ["sh", "-c", cmd],
        environment={"CONTENT": content},
    )

    # run interpreter
    interpreter_main = "~/xls/bazel-bin/xls/dslx/interpreter_main"
    error_code, error_message = container.exec_run(["sh", "-c", f"{interpreter_main} {output_path}"])


    # redirect result
    # test_output_file = os.path.join(p.parent, f"{p.stem}_test.log")
    with open (test_output_file, "w") as f:
        print(error_message.decode("utf-8"))
        f.write(error_message.decode("utf-8"))

    return not exit_code

# -----------------------------------------------------------------
# Formatting helpers
# -----------------------------------------------------------------

def spaces_to_align_dots(names: List[str], min_space: int = 7) -> List[int]:
    """
    Given a list of source names, return how many spaces to append
    after each so that all trailing periods '.' would align in
    monospaced text.

    min_space = minimum spaces between the longest name and the dot
    (default 1).
    """
    if not names:
        return []

    max_len = max(len(name) for name in names)
    dot_column = max_len + min_space  # column where '.' will appear

    # number of spaces after each name before the '.'
    return [dot_column - len(name) for name in names]

# records the result in two texts summaries:
# 1. tracks how many turns
#       source_name      2 3 1 5 X X 3 6
# 2. tracks whether or not it passes the dslx tests
#       source_name      . . . . F F F F

def main():
    with open("eval_config.yaml", "r") as f:
        config = yaml.safe_load(f)

    num_trials = config["num_trials"]
    sources = config["source"]
    test = config["test"]

    #assert len(sources) == len(tests), "must have same number of sources and tests"

    # Get the path to the summary files
    agent_summary = os.path.join(exp_dir, "agent_summary.log")
    f_agent = open(agent_summary, "a")

    dslx_summary = os.path.join(exp_dir, "dslx_summary.log")
    f_dslx = open(dslx_summary, "a")

    # Get spacing per source for summary file fomatting
    spaces = spaces_to_align_dots(sources)

    for i in range(len(sources)):

        # Write the name of the source file
        f_agent.write(f"{sources[i]}{" " * spaces[i]}")
        f_dslx.write(f"{sources[i]}{" " * spaces[i]}")

        # Run trials
        for j in range(int(num_trials)):
            source = sources[i]
            s = Path(source)

            # Generate
            generate_log_file = os.path.join(exp_dir, f"{s.stem}_{j}.log")
            test_output_file = os.path.join(exp_dir, f"{s.stem}_test_{j}.log")
            run_one(source, generate_log_file)

            # Parse result
            parsed_result = analyze_once(generate_log_file)
            print(parsed_result)
            agent_status = parsed_result["status"]
            agent_num_tries = parsed_result["number of generations"]

            ouput_file_path = parsed_result["final output file path"]
            
            # Run the test if status is success
            if agent_status == "success":
                test_file = os.path.join(LLM_DIR, "input", tests[i])
                eval_success = verify_once(test_file, ouput_file_path, test_output_file)

                # write result to dslx summary file
                if eval_success:
                    f_dslx.write(" .")
                else:
                    f_dslx.write(" F")

                # write num trials to agent summary
                f_agent.write(f" {agent_num_tries}")

            else:
                # write result to dslx summary file
                f_dslx.write(" f")

                # write num trials to agent summary
                f_agent.write(" X")

        f_dslx.write("\n")
        f_agent.write("\n")

    f_dslx.close()
    f_agent.close()

if __name__ == "__main__":
    main()